workload: Interactive
operation: complex
number: 10
title: Friend recommendation
description: |
  Given a start *Person* (`rootPerson`), find that *Person*'s friends of friends
  (`Person`) - excluding `rootPerson`, and immediate friends -, 
  who were born on or after the 21st of a given month (in any year) and before the
  22nd of the following month. Calculate the similarity between each
  `person` and `rootPerson`, where `commonInterestScore`
  is defined as follows: number of *Posts* created by that `person`,
  such that the *Post* has a *Tag* that `rootPerson` is Interested in.

parameters:
  - name: Person.id
    type: ID
    description: "`personId`"
  - name: month
    type: 32-bit Integer
    description: "`month` -- Between 1 and 12. Implementations may also pass the next month as an additional `nextMonth` parameter"
result:
  - name: Person.id
    type: ID
    description: "`personId`"
  - name: Person.firstName
    type: String
    description: "`personFirstName`"
  - name: Person.lastName
    type: String
    description: "`personLastName`"
  - name: commonInterestScore
    type: 32-bit Integer
    category: calculated
    description: "`commonInterestScore`"
  - name: Person.gender
    type: String
    description: "`personGender`"
  - name: Person-isLocatedIn->Place.name
    type: String
    description: "`personCityName`"
sort:
  - name: similarity
    direction: desc
  - name: Person.id
    direction: asc
limit: 10
choke_points: [2.3, 3.3, 4.1, 4.2, 5.1, 5.2, 6.1, 7.1]
relevance: |
  This query looks for paths of length two, starting from a Person and ending at the friends of their friends. It does
  widely scattered graph traversal, and one expects no locality of in friends of friends, as these have been acquired
  over a long time and have widely scattered identifiers. The join order is simple but one must see that the anti-join
  for "not in my friends" is better with hash. Also the last pattern in the scalar sub-queries joining or anti-joining the
  tags of the candidate's posts to interests of self should be by hash.
